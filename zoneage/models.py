"""
This holds the "Zone" class.
"""
from zoneage.db import DB
from sqlalchemy import Column, ForeignKey, Integer, String, Text, Table
from sqlalchemy.orm import relationship
from zoneage.name_id_autogen import zone_id_gen, node_id_gen, flow_id_gen

# Used for managing the info asset -> node relationships.
info_asset_node_assoc_table = Table(
    'info_asset_node_association',
    DB.base.metadata,
    Column('node_id', Integer, ForeignKey('node.id')),
    Column('information_asset_id', Integer, ForeignKey('information_asset.id'))
)

# Used for managing the info asset -> node relationships.
info_asset_flow_assoc_table = Table(
    'info_asset_flow_association',
    DB.base.metadata,
    Column('flow_id', Integer, ForeignKey('flow.id')),
    Column('information_asset_id', Integer, ForeignKey('information_asset.id'))
)

class Zone(DB.base):
    __tablename__ = "zone"
    # This is the ID used in the database. It will be automatically set and probably used for internal querying.
    id = Column(Integer, primary_key=True)

    # This is a settable Zone ID, based on the preference of the user. The app logic will look for AUTO in any JSON and
    # figure out an automatic ID.
    zone_id = Column(String(100))

    # This is the type of zone, set in the JSON. The app doesn't care about the type of zone, but users may want to use
    # it. Maybe something like "Presentation Tier", "DB Tier" or something?
    zone_type = Column(String(100), nullable=False)

    # The abstraction level is the level of abstraction the zone exists at, ie, conceptual, logical, discrete physical,
    # discrete component etc... Means zone_type can be more straightforward.
    zone_abstraction = Column(String(100))

    # The name of the network zone.
    zone_name = Column(String(100), nullable=False, unique=True)

    # A description of the Zone.
    zone_description = Column(Text)

    # An indicative trust level. Low means lower trust (the internet), higher means high trust (A secure network). Meant
    # to be a relative value to trigger some rules / other logic. Maxiumum differentials between zones can be flagged
    # for risks and the such.
    trust_level = Column(Integer)

    def load_data(self, zone_dict):
        """
        Must be a dict object from JSON.
        :return:
        """

        if zone_dict["zone_id"] == "AUTO":
            self.zone_id = next(zone_id_gen)
            print("Creating zone with ID "+self.zone_id)
        else:
            self.zone_id = zone_dict["zone_id"]

        self.zone_type = zone_dict["zone_type"]

        self.zone_abstraction = zone_dict["zone_abstraction"]

        self.zone_description = zone_dict["zone_description"]

        self.trust_level = zone_dict["trust_level"]

        self.zone_name = zone_dict["zone_name"]


class Node(DB.base):

    __tablename__ = "node"

    # Autogenerated ID.
    id = Column(Integer, primary_key=True)

    # This is the ID for the specific node. Similar to Zone ID, can be user set or set to AUTO.
    node_id = Column(String(100))

    # The node type field. This has more meaning than Zone Type. I'm thinking that it can be set to "Conceptual /
    # Logical / Physical / Network / Server" etc... etc...
    node_type = Column(String(100))

    # This is the name of the node.
    node_name = Column(String(100))

    # Node abstraction. See above, same as zone_abstraction.
    node_abstraction = Column(String(100))

    # A descrption of the node.
    node_description = Column(Text)

    # Similar to the trust_level in the zone section. Purely indicative.
    trust_level = Column(Integer)

    # The zone a node is located in.
    zone_id = Column(Integer, ForeignKey("zone.id"))

    zone = relationship(Zone)

    # Information Assets on the node.
    information_assets = relationship("InformationAsset", secondary=info_asset_node_assoc_table, back_populates="nodes_present_on")

    def load_data(self, node_dict):

        if node_dict["node_id"] == "AUTO":
            self.node_id = next(node_id_gen)
        else:
            self.node_id = node_dict["node_id"]

        self.node_name = node_dict["node_name"]

        self.zone_id = node_dict["zone_id"]


class Flow(DB.base):
    __tablename__ = "flow"

    # Autogenerated ID.
    id = Column(Integer, primary_key=True)

    # The ID you'd rather set. Or just use AUTO. I'll create an id_gen.json file for setting a schema.
    node_id = Column(String(100))

    # The name of the flow. Largely un-needed. Flows don't get to have names :(
    flow_name = Column(String(100))

    # The abstraction level.
    flow_abstraction = Column(String(100))

    # The starting node of a flow
    flow_start_node = Column(Integer, ForeignKey("node.id"))

    # The end node of a flow
    flow_end_node = Column(Integer, ForeignKey("node.id"))


class InformationAsset(DB.base):
    __tablename__ = "information_asset"

    # Autogenerated ID.
    id = Column(Integer, primary_key=True)

    # Classification
    classification = Column(String(100))

    # Description
    asset_description = Column(Text)

    # Name
    asset_name = Column(String(100))

    # Information Assets on the node.
    nodes_present_on = relationship("Node", secondary=info_asset_node_assoc_table,
                                      back_populates="information_assets")




